using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace cfEngine.Generator;

[Generator(LanguageNames.CSharp)]
public class GameItemGenerator : IIncrementalGenerator
{
    private const string AttributeMetadataName = "cfEngine.GameItem.GameItemAttribute";
    private static string AttributeSource => @"
// <auto-generated />
namespace cfEngine.GameItem 
{
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class GameItemAttribute : System.Attribute
    {
        public string ItemName { get; }
        public string DecodeMethodName { get; }
        public GameItemAttribute(string itemName, string decodeMethodName)
        {
            ItemName = itemName;
            DecodeMethodName = decodeMethodName;
        }
    }
}
";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(postInitCtx =>
        {
            postInitCtx.AddSource("GameItemAttributes.g.cs", AttributeSource);
        });

        var marked = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttributeMetadataName,
            predicate: static (node, _) => node is ClassDeclarationSyntax,
            transform: static (ctx, _) =>
            {
                var typeSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
                var attribute = ctx.Attributes[0];

                var itemName = attribute.ConstructorArguments.Length > 0
                    ? attribute.ConstructorArguments[0].Value as string ?? string.Empty
                    : string.Empty;

                var decodeMethod = attribute.ConstructorArguments.Length > 1
                    ? attribute.ConstructorArguments[1].Value as string ?? string.Empty
                    : string.Empty;

                return new ItemInfo(typeSymbol, itemName, decodeMethod);
            });

        var all = marked.Collect();
        
        context.RegisterSourceOutput(all, (productCtx, items) =>
        {
            var lines = new List<string>();
            
            foreach (var item in items)
            {
                if (string.IsNullOrWhiteSpace(item.ItemName) || string.IsNullOrWhiteSpace(item.DecodeMethod))
                {
                    productCtx.ReportDiagnostic(Diagnostic.Create(
                        Descriptors.BadAttributeArgs,
                        item.Type.Locations.FirstOrDefault(),
                        item.Type.ToDisplayString()
                    ));
                    continue;
                }

                var method = item.Type
                    .GetMembers(item.DecodeMethod)
                    .OfType<IMethodSymbol>()
                    .FirstOrDefault(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public);

                if (method == null)
                {
                    productCtx.ReportDiagnostic(Diagnostic.Create(
                        Descriptors.MissingMethod,
                        item.Type.Locations.FirstOrDefault(),
                        item.Type.ToDisplayString(),
                        item.DecodeMethod
                    ));
                    continue;
                }

                var fqType = item.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var escaped = item.ItemName.Replace("\"", "\\\"");
                lines.Add($"            Register(\"{escaped}\", {fqType}.{item.DecodeMethod});");
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />")
                .AppendLine("namespace cfEngine.GameItem")
                .AppendLine("{")
                .AppendLine("    public static partial class GameItemFactory")
                .AppendLine("    {")
                .AppendLine("        static partial void RegisterDecoders()")
                .AppendLine("        {");

            foreach (var l in lines.Distinct())
                sb.AppendLine(l);

            sb.AppendLine("        }")
                .AppendLine("    }")
                .AppendLine("}");

            productCtx.AddSource("GameItemFactory.RegisterDecoders.g.cs", sb.ToString());
        });
    }

    private readonly struct ItemInfo(INamedTypeSymbol Type, string ItemName, string DecodeMethod)
    {
        public INamedTypeSymbol Type { get; } = Type;
        public string ItemName { get; } = ItemName;
        public string DecodeMethod { get; } = DecodeMethod;
    }

    private static class Descriptors
    {
        public static readonly DiagnosticDescriptor MissingMethod = new(
            id: "CFG001",
            title: "Decode method not found",
            messageFormat: "Type '{0}' does not contain a public static method named '{1}'",
            category: "cfEngine.GameItem",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        public static readonly DiagnosticDescriptor BadAttributeArgs = new(
            id: "CFG003",
            title: "Invalid [GameItem] arguments",
            messageFormat: "Type '{0}' has invalid or empty GameItem attribute arguments",
            category: "cfEngine.GameItem",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);
    }
}
